import 'package:diabetic_diary/database.dart';
import 'package:diabetic_diary/entities/dish.dart';
import 'package:diabetic_diary/entities/ingredient.dart';
import 'package:diabetic_diary/translation.dart';
import 'package:diabetic_diary/unit.dart';
import 'package:moor/ffi.dart';
import 'package:moor/moor.dart';
import 'package:path_provider/path_provider.dart';
import 'package:path/path.dart' as p;
import 'dart:io';

import '../indexable.dart';
import '../measurement_type.dart';
import 'mock_database.dart';

// Include the autogenerated code
part 'moor_database.g.dart';

class _DimensionComponents extends Table {
  TextColumn get dimensionId => text()();
  TextColumn get componentId => text()();
  IntColumn get exponent => integer()();

  @override
  Set<Column> get primaryKey => {dimensionId, componentId};
}

class _DimensionUnits extends Table {
  TextColumn get dimensionId => text()();
  TextColumn get unitId => text()();
  RealColumn get multiplier => real()();

  @override
  Set<Column> get primaryKey => {dimensionId, unitId};
}

class _MeasurementTypes extends Table {
  TextColumn get id => text()();
  TextColumn get unitId => text()();

  @override
  Set<Column> get primaryKey => {id};
}

class _CompositionStatistics extends Table {
  TextColumn get id => text()();
  TextColumn get unitId => text()();

  @override
  Set<Column> get primaryKey => {id};
}
class _Ingredients extends Table {
  TextColumn get id => text()();
  TextColumn get measurementId => text()();
  TextColumn get unitId => text()();
  RealColumn get amount => real()();

  @override
  Set<Column> get primaryKey => {id, measurementId};
}

@DataClassName("_Dish")
class _Dishes extends Table {
  TextColumn get id => text()();
  TextColumn get ingredientId => text()();
  TextColumn get unitId => text()();
  RealColumn get amount => real()();

  @override
  Set<Column> get primaryKey => {id, ingredientId};
}

LazyDatabase _openConnection() {
  // the LazyDatabase util lets us find the right location for the file async.
  return LazyDatabase(() async {
    // put the database file, called db.sqlite here, into the documents folder
    // for your app.
    final dbFolder = await getApplicationDocumentsDirectory();
    final file = File(p.join(dbFolder.path, 'db.sqlite'));
    return VmDatabase(file);
  });
}

@UseMoor(tables: [_DimensionUnits, _DimensionComponents, _MeasurementTypes, _CompositionStatistics, _Ingredients, _Dishes])
class _MoorDatabase extends _$_MoorDatabase {
  // we tell the database where to store the data with this constructor
  _MoorDatabase() : super(_openConnection());

  // you should bump this number whenever you change or add a table definition. Migrations
  // are covered later in this readme.
  @override
  int get schemaVersion => 1;
}


class MoorDatabase extends Database {
  final _MoorDatabase db;

  MoorDatabase(this.db) :
        dimensions = MoorDimensionsCollection(db),
        units = MoorDataCollection<Units>(db),
        measurementTypes = MoorMTypeCollection(db),
        compositionStatistics = MoorCStatCollection(db),
        ingredients = MoorIngredientCollection(db),
        dishes = MoorDataCollection<Dish>(db),
        config = MockDataCollection<DPair>();

  static MoorDatabase create() {
    return MoorDatabase(_MoorDatabase());
  }


  @override
  final AsyncDataCollection<Dimensions> dimensions;

  @override
  final AsyncDataCollection<Units> units;

  @override
  final AsyncDataCollection<MeasurementType> measurementTypes;

  @override
  final AsyncDataCollection<MeasurementType> compositionStatistics;

  @override
  final AsyncDataCollection<Ingredient> ingredients;

  @override
  final AsyncDataCollection<Dish> dishes;

  @override
  final AsyncDataCollection<DPair> config;
}
class MoorDataCollection<T extends Indexable> implements AsyncDataCollection<T> {
  final _MoorDatabase db;

  MoorDataCollection(this.db);

  @override
  Future<Symbol> add(T value) {
    // TODO: implement add
    throw UnimplementedError();
  }

  @override
  Future<Map<Symbol, T>> cannedQuery(Symbol name, [List? parameters]) {
    // TODO: implement cannedQuery
    throw UnimplementedError();
  }

  @override
  Future<int> count() {
    // TODO: implement count
    throw UnimplementedError();
  }

  @override
  Future<T> fetch(Symbol index) {
    // TODO: implement fetch
    throw UnimplementedError();
  }

  @override
  void forEach(void Function(Symbol p1, T p2) visitor) {
    // TODO: implement forEach
  }

  @override
  Future<T> get(Symbol index, T otherwise) {
    // TODO: implement get
    throw UnimplementedError();
  }

  @override
  Future<Map<Symbol, T>> getAll() {
    // TODO: implement getAll
    throw UnimplementedError();
  }

  @override
  Future<T?> maybeGet(Symbol index, [T? otherwise]) {
    // TODO: implement maybeGet
    throw UnimplementedError();
  }

  @override
  void put(Symbol index, T value) {
    // TODO: implement put
  }

  @override
  void remove(Symbol index) {
    // TODO: implement remove
  }

  @override
  Future<int> removeAll() {
    // TODO: implement removeAll
    throw UnimplementedError();
  }
}

class MoorDimensionsCollection implements AsyncDataCollection<Dimensions> {
  final _MoorDatabase db;

  MoorDimensionsCollection(this.db);

  @override
  Future<Symbol> add(Dimensions dimensions) {
    dimensions.components.forEach((key, value) {
      db.into(db.dimensionComponents).insert(_DimensionComponentsCompanion(
        dimensionId: Value(symbolToString(dimensions.id)),
        componentId: Value(symbolToString(key)),
        exponent: Value(value),
      ));
    });
    return Future(() => dimensions.id);
  }

  @override
  Future<Map<Symbol, Dimensions>> cannedQuery(Symbol name, [List? parameters]) {
    // TODO: implement cannedQuery
    throw UnimplementedError();
  }

  @override
  Future<int> count() async {
    final count = db.dimensionUnits.dimensionId.count(distinct: true);
    final query = db.selectOnly(db.dimensionUnits)
      ..addColumns([count]);

    final r = await query.getSingle();
    return r.read(count);
  }

  @override
  Future<Dimensions> fetch(Symbol index) async {
    final results = db
      .select(db.dimensionComponents, distinct: true)
      ..where((a) => a.dimensionId.equals(symbolToString(index)));
    final rows = await results.get();
    // Convert the list of rows into a map from dimension id to exponent
    final components = Map.fromEntries(rows.map((component) =>
        MapEntry(Symbol(component.dimensionId), component.exponent)));
    // Use that map to construct a Dimensions instance
    return Dimensions(id: index, components: components); 
  }

  @override
  void forEach(void Function(Symbol p1, Dimensions p2) visitor) {
    // TODO: implement forEach
  }

  @override
  Future<Dimensions> get(Symbol index, Dimensions otherwise) {
    // TODO: implement get
    throw UnimplementedError();
  }

  @override
  Future<Map<Symbol, Dimensions>> getAll() {
    // TODO: implement getAll
    throw UnimplementedError();
  }

  @override
  Future<Dimensions?> maybeGet(Symbol index, [Dimensions? otherwise]) {
    // TODO: implement maybeGet
    throw UnimplementedError();
  }

  @override
  void put(Symbol index, Dimensions value) {
    // TODO: implement put
  }

  @override
  void remove(Symbol index) {
    // TODO: implement remove
  }

  @override
  Future<int> removeAll() {
    // TODO: implement removeAll
    throw UnimplementedError();
  }
}

abstract class MoorUnitRefCollection<T extends Table, D extends DataClass> implements AsyncDataCollection<MeasurementType> {
  final _MoorDatabase db;
  final TableInfo<T, D> tableInfo;
  final GeneratedTextColumn joinCol;
  final JoinedSelectStatement<Table, dynamic> commonQuery;

  MoorUnitRefCollection(this.db, this.tableInfo, this.joinCol) :
      commonQuery = db.select(tableInfo)
        .join([
          leftOuterJoin(db.dimensionUnits, joinCol.equalsExp(db.dimensionUnits.unitId))
        ]);

  Insertable<D> valueToRow(MeasurementType val);
  MeasurementType rowToValue(TypedResult row);

  @override
  Future<Symbol> add(MeasurementType value) async {
    final row = valueToRow(value);
    await db.into(tableInfo).insertOnConflictUpdate(row);
    return Future(() => value.id);
  }

  @override
  Future<Map<Symbol, MeasurementType>> cannedQuery(Symbol name, [List? parameters]) {
    // TODO: implement cannedQuery
    throw UnimplementedError();
  }

  @override
  Future<int> count() {
    // TODO: implement count
    throw UnimplementedError();
  }

  @override
  Future<MeasurementType> fetch(Symbol index) async {
    final results = commonQuery
      ..where(db.dimensionUnits.unitId.equals(symbolToString(index)));

    final value = await results.getSingle();
    final unitsRow = value.readTable(db.dimensionUnits);
    final units = Units(Symbol(unitsRow.unitId), Symbol(unitsRow.dimensionId), unitsRow.multiplier);
    return MeasurementType(id: index, units: units);
  }

  @override
  void forEach(void Function(Symbol p1, MeasurementType p2) visitor) {
    // TODO: implement forEach
  }

  @override
  Future<MeasurementType> get(Symbol index, MeasurementType otherwise) async {
    final results = commonQuery
      ..where(db.dimensionUnits.unitId.equals(symbolToString(index)));

    final value = await results.getSingleOrNull();
    if (value == null)
      return otherwise;
    final unitsRow = value.readTable(db.dimensionUnits);
    final units = Units(Symbol(unitsRow.unitId), Symbol(unitsRow.dimensionId), unitsRow.multiplier);
    return MeasurementType(id: index, units: units);
  }

  @override
  Future<Map<Symbol, MeasurementType>> getAll() async {
    final results = db
        .select(db.compositionStatistics)
        .join([
          leftOuterJoin(db.dimensionUnits, db.compositionStatistics.unitId.equalsExp(db.dimensionUnits.unitId))
        ]);

    final values = await results.get();
    return Map.fromEntries(values.map((row) {
      final val = rowToValue(row); // FIXME why is this nullable?
      return MapEntry(val.id, val);
    }));
  }

  @override
  Future<MeasurementType?> maybeGet(Symbol index, [MeasurementType? otherwise]) {
    // TODO: implement maybeGet
    throw UnimplementedError();
  }

  @override
  void put(Symbol index, MeasurementType value) {
    // TODO: implement put
  }

  @override
  void remove(Symbol index) {
    // TODO: implement remove
  }

  @override
  Future<int> removeAll() {
    // TODO: implement removeAll
    throw UnimplementedError();
  }

}

class MoorCStatCollection extends MoorUnitRefCollection<$_CompositionStatisticsTable, _CompositionStatistic> {

  MoorCStatCollection(_MoorDatabase db) : super(db, db.compositionStatistics, db.compositionStatistics.unitId);

  @override
  MeasurementType rowToValue(TypedResult row) {
    final id = Symbol(row.read(db.compositionStatistics.id) ?? ''); // FIXME why is this nullable?
    final unitsRow = row.readTable(db.dimensionUnits);
    final units = Units(Symbol(unitsRow.unitId), Symbol(unitsRow.dimensionId), unitsRow.multiplier);
    return MeasurementType(id: id, units: units);
  }

  @override
  Insertable<_CompositionStatistic> valueToRow(MeasurementType val) {
    return _CompositionStatistic(id: symbolToString(val.id), unitId: symbolToString(val.units.id));
  }
}

class MoorMTypeCollection extends MoorUnitRefCollection<$_MeasurementTypesTable, _MeasurementType> {

  MoorMTypeCollection(_MoorDatabase db) : super(db, db.measurementTypes, db.measurementTypes.unitId);

  @override
  MeasurementType rowToValue(TypedResult row) {
    final id = Symbol(row.read(db.compositionStatistics.id) ?? ''); // FIXME why is this nullable?
    final unitsRow = row.readTable(db.dimensionUnits);
    final units = Units(Symbol(unitsRow.unitId), Symbol(unitsRow.dimensionId), unitsRow.multiplier);
    return MeasurementType(id: id, units: units);
  }

  @override
  Insertable<_MeasurementType> valueToRow(MeasurementType val) {
    return _MeasurementType(id: symbolToString(val.id), unitId: symbolToString(val.units.id));
  }
}

class MoorIngredientCollection/*< T extends Table, D extends DataClass>*/ implements AsyncDataCollection<Ingredient> {
  final _MoorDatabase db;/*
  final TableInfo<T, D> tableInfo;
  final GeneratedTextColumn joinCol;
  final JoinedSelectStatement<Table, dynamic> commonQuery;

  MoorIngredientCollection(this.db, this.tableInfo, this.joinCol) :
        commonQuery = db.select(tableInfo)
            .join([
          leftOuterJoin(db.dimensionUnits, joinCol.equalsExp(db.dimensionUnits.unitId))
        ]);


  MeasurementType rowToValue(TypedResult row);
*/
  MoorIngredientCollection(this.db);

  Iterable<_Ingredient> valueToRows(Ingredient val) {
    return val.compositionStats.entries
        .map((stat) => _Ingredient(
            id: symbolToString(val.id),
            measurementId: symbolToString(stat.key.id), //symbolToString(val.compositionStats.first()),
            unitId: symbolToString(stat.key.units.id),
            amount: stat.value.amount.toDouble(),
          )
        );
  }

  @override
  Future<Symbol> add(Ingredient value) async {
    final rows = valueToRows(value); // FIXME stream this?
    await Future.forEach(
        rows,
        (_Ingredient row) => db.into(db.ingredients).insertOnConflictUpdate(row),
    );
    return value.id;
  }

  @override
  Future<Map<Symbol, Ingredient>> cannedQuery(Symbol name, [List? parameters]) {
    // TODO: implement cannedQuery
    throw UnimplementedError();
  }

  @override
  Future<int> count() {
    // TODO: implement count
    throw UnimplementedError();
  }

  @override
  Future<Ingredient> fetch(Symbol index) async {
    final results = db
      .select(db.ingredients)
      .join([
        leftOuterJoin(db.dimensionUnits, db.dimensionUnits.unitId.equalsExp(db.ingredients.unitId))
      ])
      ..where(db.ingredients.id.equals(symbolToString(index)));
    final rows = await results.get();
    // Convert the list of rows into a map from dimension id to exponent
    final stats = Map.fromEntries(rows.map((row) {
      final ingRow = row.readTable(db.ingredients);
      final unitsRow = row.readTable(db.dimensionUnits);
      final measId = Symbol(ingRow.measurementId);
      final unitsId = Symbol(ingRow.unitId);
      final dimId = Symbol(unitsRow.dimensionId);
      final multiplier = unitsRow.multiplier;
      final units = Units(unitsId, dimId, multiplier);
      final measurementType = MeasurementType(id: measId, units: units);
      final quantity = Quantity(ingRow.amount, units);
      return MapEntry(measurementType, quantity);
    }));

    // Use that map to construct an instance
    return Ingredient(id: index, compositionStats: stats);
  }

  @override
  void forEach(void Function(Symbol p1, Ingredient p2) visitor) {
    // TODO: implement forEach
  }

  @override
  Future<Ingredient> get(Symbol index, Ingredient otherwise) {
    // TODO: implement get
    throw UnimplementedError();
  }

  @override
  Future<Map<Symbol, Ingredient>> getAll() {
    // TODO: implement getAll
    throw UnimplementedError();
  }

  @override
  Future<Ingredient?> maybeGet(Symbol index, [Ingredient? otherwise]) {
    // TODO: implement maybeGet
    throw UnimplementedError();
  }

  @override
  void put(Symbol index, Ingredient value) {
    // TODO: implement put
  }

  @override
  void remove(Symbol index) {
    // TODO: implement remove
  }

  @override
  Future<int> removeAll() {
    // TODO: implement removeAll
    throw UnimplementedError();
  }

}
